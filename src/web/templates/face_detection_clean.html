<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Face Landmark Detection Test</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        background: white;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .video-container {
        position: relative;
        display: inline-block;
        margin: 20px;
      }

      #webcam {
        border: 3px solid #007bff;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      #landmarkCanvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        border: 3px solid transparent;
        border-radius: 10px;
      }

      .controls {
        text-align: center;
        margin: 20px 0;
      }

      .btn {
        padding: 12px 24px;
        margin: 0 10px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
      }

      .btn-primary {
        background-color: #007bff;
        color: white;
      }

      .btn-danger {
        background-color: #dc3545;
        color: white;
      }

      .btn-success {
        background-color: #28a745;
        color: white;
      }

      .btn:hover {
        opacity: 0.8;
        transform: translateY(-2px);
      }

      .btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .info-panel {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .info-card {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        border-left: 4px solid #007bff;
      }

      .info-card h3 {
        margin: 0 0 10px 0;
        color: #333;
        font-size: 18px;
      }

      .status-badge {
        display: inline-block;
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: bold;
        text-transform: uppercase;
        margin: 2px;
      }

      .status-success {
        background: #d4edda;
        color: #155724;
      }

      .status-warning {
        background: #fff3cd;
        color: #856404;
      }

      .status-danger {
        background: #f8d7da;
        color: #721c24;
      }

      .status-info {
        background: #d1ecf1;
        color: #0c5460;
      }

      .security-score {
        font-size: 24px;
        font-weight: bold;
        text-align: center;
        padding: 10px;
        border-radius: 8px;
        margin: 10px 0;
      }

      .score-high {
        background: #d4edda;
        color: #155724;
      }

      .score-medium {
        background: #fff3cd;
        color: #856404;
      }

      .score-low {
        background: #f8d7da;
        color: #721c24;
      }

      .messages {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 8px;
        padding: 15px;
        margin: 20px 0;
        max-height: 300px;
        overflow-y: auto;
      }

      .message {
        margin: 5px 0;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
      }

      .message.info {
        background: #d1ecf1;
        color: #0c5460;
        border-left: 3px solid #17a2b8;
      }

      .message.success {
        background: #d4edda;
        color: #155724;
        border-left: 3px solid #28a745;
      }

      .message.warning {
        background: #fff3cd;
        color: #856404;
        border-left: 3px solid #ffc107;
      }

      .message.error {
        background: #f8d7da;
        color: #721c24;
        border-left: 3px solid #dc3545;
      }

      .timestamp {
        font-size: 11px;
        opacity: 0.7;
        float: right;
      }

      .landmark-info {
        font-size: 12px;
        color: #666;
        margin-top: 10px;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin: 10px 0;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 5px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 12px;
      }

      .color-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>üîç Face Landmark Detection Test</h1>
      <p>
        Test halaman untuk validasi deteksi landmark wajah dengan visualisasi
        titik-titik landmark secara real-time.
      </p>

      <!-- Video Container -->
      <div class="video-container">
        <video
          id="webcam"
          width="640"
          height="480"
          autoplay
          muted
          playsinline
        ></video>
        <canvas id="landmarkCanvas" width="640" height="480"></canvas>
      </div>

      <!-- Controls -->
      <div class="controls">
        <button id="startBtn" class="btn btn-primary" onclick="startCamera()">
          üìπ Start Camera
        </button>
        <button
          id="stopBtn"
          class="btn btn-danger"
          onclick="stopCamera()"
          disabled
        >
          ‚èπÔ∏è Stop Camera
        </button>
        <button
          id="testBtn"
          class="btn btn-success"
          onclick="testVerification()"
          disabled
        >
          üß™ Test Verification
        </button>
      </div>

      <!-- Landmark Legend -->
      <div class="legend">
        <div class="legend-item">
          <div class="color-dot" style="background: #00ff00"></div>
          <span>Face Outline</span>
        </div>
        <div class="legend-item">
          <div class="color-dot" style="background: #ff0000"></div>
          <span>Eyes</span>
        </div>
        <div class="legend-item">
          <div class="color-dot" style="background: #0000ff"></div>
          <span>Nose</span>
        </div>
        <div class="legend-item">
          <div class="color-dot" style="background: #ffff00"></div>
          <span>Mouth</span>
        </div>
        <div class="legend-item">
          <div class="color-dot" style="background: #ff00ff"></div>
          <span>Eyebrows</span>
        </div>
      </div>

      <!-- Info Panel -->
      <div class="info-panel">
        <!-- Landmark Detection Info -->
        <div class="info-card">
          <h3>üéØ Landmark Detection</h3>
          <div id="landmarkInfo">
            <div class="status-badge status-info">Waiting...</div>
            <div class="landmark-info">
              Ready to detect 468 facial landmarks
            </div>
          </div>
        </div>

        <!-- Liveness Detection Info -->
        <div class="info-card">
          <h3>üíó Liveness Detection</h3>
          <div id="livenessInfo">
            <div class="status-badge status-info">Waiting...</div>
            <div class="landmark-info">Motion and depth analysis</div>
          </div>
        </div>

        <!-- CNN Analysis Info -->
        <div class="info-card">
          <h3>üß† CNN Analysis</h3>
          <div id="cnnInfo">
            <div class="status-badge status-info">Waiting...</div>
            <div class="landmark-info">Deep learning verification</div>
          </div>
        </div>

        <!-- Security Score -->
        <div class="info-card">
          <h3>üõ°Ô∏è Security Score</h3>
          <div id="securityScore" class="security-score score-medium">
            Calculating...
          </div>
          <div id="securityStatus" class="landmark-info">
            Multi-layer security analysis
          </div>
        </div>
      </div>

      <!-- Messages -->
      <div class="messages">
        <h3>üìã System Messages</h3>
        <div id="messageList"></div>
      </div>
    </div>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
      // ===== GLOBAL VARIABLES =====
      let webcam = null;
      let canvas = null;
      let ctx = null;
      let socket = null;
      let isProcessing = false;
      let frameCount = 0;
      let sessionId = Date.now(); // Global session ID

      // ===== DEBUGGING ENABLED =====
      console.log("=== DEBUG: Page loaded, initializing variables ===");

      // ===== GLOBAL FUNCTIONS =====
      window.startCamera = function () {
        console.log("=== DEBUG: startCamera called ===");
        addMessage("Starting camera...", "info");

        navigator.mediaDevices
          .getUserMedia({
            video: {
              width: 640,
              height: 480,
              facingMode: "user",
            },
          })
          .then((stream) => {
            console.log("=== DEBUG: Camera stream obtained ===", stream);
            webcam = document.getElementById("webcam");
            webcam.srcObject = stream;

            // Wait for video to load before setting up canvas
            webcam.onloadedmetadata = function () {
              console.log(
                "=== DEBUG: Video metadata loaded, dimensions:",
                webcam.videoWidth,
                "x",
                webcam.videoHeight
              );

              // Initialize canvas with correct dimensions
              canvas = document.getElementById("landmarkCanvas");
              canvas.width = webcam.videoWidth;
              canvas.height = webcam.videoHeight;
              ctx = canvas.getContext("2d");
              console.log(
                "=== DEBUG: Canvas initialized:",
                canvas.width,
                "x",
                canvas.height
              );

              // Initialize Socket.IO
              console.log("=== DEBUG: Initializing Socket.IO ===");
              socket = io();

              // Set up event listeners with extensive debugging
              socket.on("landmark_result", function (data) {
                console.log("=== DEBUG: Received landmark_result ===", data);
                handleLandmarkResult(data);
              });

              socket.on("connect", () => {
                console.log("=== DEBUG: Socket.IO connected ===");
                addMessage("Connected to server", "success");

                // Auto-start real-time processing when connected
                if (!isProcessing) {
                  console.log(
                    "=== DEBUG: Auto-starting real-time processing ==="
                  );
                  isProcessing = true;
                  processFrames();
                  addMessage("Real-time landmark detection started", "info");
                }
              });

              socket.on("disconnect", () => {
                console.log("=== DEBUG: Socket.IO disconnected ===");
                addMessage("Disconnected from server", "warning");
              });

              socket.on("error", (error) => {
                console.log("=== DEBUG: Socket.IO error ===", error);
                addMessage("Socket error: " + error.message, "error");
              });

              // Update UI
              document.getElementById("startBtn").disabled = true;
              document.getElementById("stopBtn").disabled = false;
              document.getElementById("testBtn").disabled = false;

              addMessage("Camera started successfully", "success");

              // Enable processing
              isProcessing = true;
              console.log("=== DEBUG: Starting frame processing ===");

              // Start processing frames
              processFrames();
            };
          })
          .catch((error) => {
            console.error("=== DEBUG: Camera error ===", error);
            addMessage("Camera error: " + error.message, "error");
          });
      };

      window.stopCamera = function () {
        if (webcam && webcam.srcObject) {
          const tracks = webcam.srcObject.getTracks();
          tracks.forEach((track) => track.stop());
          webcam.srcObject = null;
        }

        if (socket) {
          socket.disconnect();
          socket = null;
        }

        // Clear canvas
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        isProcessing = false;

        // Update UI
        document.getElementById("startBtn").disabled = false;
        document.getElementById("stopBtn").disabled = true;
        document.getElementById("testBtn").disabled = true;

        // Reset info panels
        updateLandmarkInfo("Stopped", "info");
        updateLivenessInfo("Stopped", "info");
        updateCNNInfo("Stopped", "info");
        updateSecurityStatus("Not Active", "medium");

        addMessage("Camera stopped", "info");
      };

      window.testVerification = function () {
        console.log("=== DEBUG: testVerification called ===");

        if (!webcam || !socket) {
          console.log(
            "=== DEBUG: Camera not started - webcam:",
            !!webcam,
            "socket:",
            !!socket
          );
          addMessage("Camera not started", "error");
          return;
        }

        if (!webcam.videoWidth || !webcam.videoHeight) {
          console.log(
            "=== DEBUG: Video not ready - dimensions:",
            webcam.videoWidth,
            "x",
            webcam.videoHeight
          );
          addMessage("Video not ready", "error");
          return;
        }

        console.log("=== DEBUG: Running ONE-TIME verification test ===");
        addMessage("Running ONE-TIME verification test...", "info");

        try {
          // Capture current frame and send for analysis
          const canvas = document.createElement("canvas");
          canvas.width = webcam.videoWidth;
          canvas.height = webcam.videoHeight;
          const ctx = canvas.getContext("2d");
          ctx.drawImage(webcam, 0, 0);

          const imageData = canvas.toDataURL("image/jpeg", 0.8);
          console.log(
            "=== DEBUG: Image captured, size:",
            imageData.length,
            "bytes"
          );

          const frameData = {
            image: imageData,
            test_mode: true, // Only for this one test
            session_id: Date.now(),
          };

          console.log(
            "=== DEBUG: Emitting ONE-TIME test process_frame event ===",
            {
              session_id: frameData.session_id,
              image_size: imageData.length,
              test_mode: true,
            }
          );

          socket.emit("process_frame", frameData);
          addMessage("Frame sent for test analysis", "info");
        } catch (error) {
          console.error("=== DEBUG: Error in testVerification ===", error);
          addMessage("Verification error: " + error.message, "error");
        }
      };

      // ===== HELPER FUNCTIONS =====
      function processFrames() {
        if (!isProcessing || !webcam || !socket) {
          console.log(
            "=== DEBUG: processFrames stopped - isProcessing:",
            isProcessing,
            "webcam:",
            !!webcam,
            "socket:",
            !!socket
          );
          return;
        }

        try {
          frameCount++;

          // Process every 10th frame for real-time tracking (was 30, now more frequent)
          if (frameCount % 10 === 0) {
            console.log("=== DEBUG: Processing REAL frame #", frameCount);

            if (!webcam.videoWidth || !webcam.videoHeight) {
              console.log("=== DEBUG: Video not ready yet, skipping frame");
              requestAnimationFrame(processFrames);
              return;
            }

            const canvas = document.createElement("canvas");
            canvas.width = webcam.videoWidth;
            canvas.height = webcam.videoHeight;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(webcam, 0, 0);

            const imageData = canvas.toDataURL("image/jpeg", 0.8);

            const frameData = {
              image: imageData,
              frame_number: frameCount,
              session_id: sessionId || Date.now(),
              test_mode: false, // CRITICAL: Use REAL landmarks, not test mode
            };

            console.log(
              "=== DEBUG: Emitting REAL frame",
              frameCount,
              "size:",
              imageData.length,
              "test_mode:",
              frameData.test_mode
            );
            socket.emit("process_frame", frameData);
          }

          requestAnimationFrame(processFrames);
        } catch (error) {
          console.error("=== DEBUG: Frame processing error ===", error);
          addMessage("Frame processing error: " + error.message, "error");
          // Continue processing despite errors
          requestAnimationFrame(processFrames);
        }
      }

      function handleLandmarkResult(data) {
        console.log("=== DEBUG: handleLandmarkResult called ===", data);

        try {
          // Check if this is test mode data
          if (data.test_mode) {
            console.log("=== DEBUG: Processing TEST mode landmarks ===");
            addMessage("Test mode: Showing test landmarks", "info");
          } else {
            console.log("=== DEBUG: Processing REAL MediaPipe landmarks ===");
            addMessage("Real-time: MediaPipe landmarks detected", "success");
          }

          if (data.landmarks && data.landmarks.length > 0) {
            console.log(
              "=== DEBUG: Drawing",
              data.landmarks.length,
              data.test_mode ? "TEST" : "REAL",
              "landmarks ==="
            );
            drawLandmarks(data.landmarks);
            updateLandmarkInfo(
              `${data.landmarks.length} ${
                data.test_mode ? "test" : "real"
              } points detected`,
              data.test_mode ? "info" : "success"
            );
          } else {
            console.log(
              "=== DEBUG: No landmarks detected, clearing canvas ==="
            );
            if (ctx && canvas) {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            updateLandmarkInfo("No face detected", "warning");
          }

          // Update other components
          if (data.liveness_score !== undefined) {
            console.log(
              "=== DEBUG: Updating liveness score:",
              data.liveness_score
            );

            // Use raw score (0-100) for display if available, otherwise convert from 0-1
            const rawScore =
              data.liveness_raw_score || data.liveness_score * 100;
            const displayScore = rawScore.toFixed(1);
            const status =
              data.liveness_status ||
              (data.liveness_score > 0.7
                ? "LIVE"
                : data.liveness_score > 0.4
                ? "UNCERTAIN"
                : "FAKE");

            const statusClass =
              data.liveness_score > 0.7
                ? "success"
                : data.liveness_score > 0.4
                ? "warning"
                : "danger";

            updateLivenessInfo(
              `Score: ${displayScore}/100 (${status})`,
              statusClass
            );

            // Add detailed liveness metrics if available
            if (data.liveness_metrics) {
              const metrics = data.liveness_metrics;
              const metricsText = `Blinks: ${metrics.blinks || 0}, Movement: ${
                metrics.head_movement_range ? "Yes" : "No"
              }`;
              console.log("=== DEBUG: Liveness metrics:", metricsText);
            }
          }

          if (data.cnn_confidence !== undefined) {
            console.log(
              "=== DEBUG: Updating CNN confidence:",
              data.cnn_confidence
            );
            const status =
              data.cnn_confidence > 0.8
                ? "success"
                : data.cnn_confidence > 0.5
                ? "warning"
                : "danger";
            updateCNNInfo(
              `Confidence: ${data.cnn_confidence.toFixed(2)}`,
              status
            );
          }

          if (data.security_score !== undefined) {
            console.log(
              "=== DEBUG: Updating security score:",
              data.security_score
            );
            const level =
              data.security_score > 0.8
                ? "high"
                : data.security_score > 0.5
                ? "medium"
                : "low";
            updateSecurityStatus(
              `${(data.security_score * 100).toFixed(1)}%`,
              level
            );
          }
        } catch (error) {
          console.error("=== DEBUG: Result handling error ===", error);
          addMessage("Result handling error: " + error.message, "error");
        }
      }

      function drawLandmarks(landmarks) {
        console.log(
          "=== DEBUG: drawLandmarks called with",
          landmarks.length,
          "points ==="
        );

        if (!ctx || !canvas) {
          console.error("=== DEBUG: Canvas or context not available ===");
          return;
        }

        // Clear previous landmarks
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        console.log(
          "=== DEBUG: Canvas cleared, dimensions:",
          canvas.width,
          "x",
          canvas.height
        );

        // Draw all landmark points using the data from backend
        let pointsDrawn = 0;
        landmarks.forEach((landmark, index) => {
          // Landmarks from backend are normalized (0-1), convert to canvas coordinates
          const x = landmark.x * canvas.width;
          const y = landmark.y * canvas.height;

          // Use color from backend or default to white
          const color = landmark.color || "#FFFFFF";

          // Only draw points that are within canvas bounds
          if (x >= 0 && x <= canvas.width && y >= 0 && y <= canvas.height) {
            // Draw landmark point with outline for better visibility
            ctx.beginPath();
            ctx.arc(x, y, 2, 0, 2 * Math.PI); // Smaller points (2px radius)
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 0.5;
            ctx.stroke();

            pointsDrawn++;
          } else {
            console.log(
              `=== DEBUG: Point ${index} out of bounds: (${x}, ${y}) ===`
            );
          }
        });

        console.log(
          "=== DEBUG: Drew",
          pointsDrawn,
          "landmark points on canvas ==="
        );

        // Remove the test dot - we don't need it anymore since landmarks are working
        // console.log("=== DEBUG: Drew test dot at (50,50) ===");
      }

      function updateLandmarkInfo(text, status) {
        const element = document.getElementById("landmarkInfo");
        element.innerHTML = `
                <div class="status-badge status-${status}">${text}</div>
                <div class="landmark-info">MediaPipe facial landmarks</div>
            `;
      }

      function updateLivenessInfo(text, status) {
        const element = document.getElementById("livenessInfo");
        element.innerHTML = `
                <div class="status-badge status-${status}">${text}</div>
                <div class="landmark-info">Live face detection (blink, movement, depth)</div>
            `;
      }

      function updateCNNInfo(text, status) {
        const element = document.getElementById("cnnInfo");
        element.innerHTML = `
                <div class="status-badge status-${status}">${text}</div>
                <div class="landmark-info">Deep learning verification</div>
            `;
      }

      function updateSecurityStatus(text, level) {
        const scoreElement = document.getElementById("securityScore");
        const statusElement = document.getElementById("securityStatus");

        scoreElement.className = `security-score score-${level}`;
        scoreElement.textContent = text;
        statusElement.textContent = "Multi-layer security analysis";
      }

      function addMessage(text, type = "info") {
        const messageList = document.getElementById("messageList");
        const timestamp = new Date().toLocaleTimeString();

        const messageElement = document.createElement("div");
        messageElement.className = `message ${type}`;
        messageElement.innerHTML = `
                <span class="timestamp">${timestamp}</span>
                ${text}
            `;

        messageList.appendChild(messageElement);
        messageList.scrollTop = messageList.scrollHeight;

        // Limit to last 20 messages
        while (messageList.children.length > 20) {
          messageList.removeChild(messageList.firstChild);
        }
      }

      // ===== INITIALIZATION =====
      document.addEventListener("DOMContentLoaded", function () {
        addMessage("System initialized successfully", "success");
        addMessage('Click "Start Camera" to begin landmark detection', "info");

        // Initialize processing flag
        isProcessing = true;

        // Initialize info panels
        updateLandmarkInfo("Ready", "info");
        updateLivenessInfo("Ready", "info");
        updateCNNInfo("Ready", "info");
        updateSecurityStatus("Ready", "medium");
      });
    </script>
  </body>
</html>
